{"package_name":"cats.instances","file_name":"cats.instances.all","short_description":"","kind":"object","case_class_link":null,"class_link":null,"object_link":"cats/instances/package$$all$.html","trait_link":null,"function_block":{"label":"catsStdNonEmptyParallelForSeqZipSeq","tail":"(): Aux[Seq, ZipSeq]","member":"cats.instances.SeqInstances.catsStdNonEmptyParallelForSeqZipSeq","link":"cats/instances/package$$all$.html#catsStdNonEmptyParallelForSeqZipSeq:cats.NonEmptyParallel.Aux[Seq,cats.data.ZipSeq]","kind":"implicit def"}}
{"package_name":"cats.instances","file_name":"cats.instances.all","short_description":"","kind":"object","case_class_link":null,"class_link":null,"object_link":"cats/instances/package$$all$.html","trait_link":null,"function_block":{"label":"catsStdTraverseFilterForSeq","tail":": TraverseFilter[Seq]","member":"cats.instances.SeqInstances.catsStdTraverseFilterForSeq","link":"cats/instances/package$$all$.html#catsStdTraverseFilterForSeq:cats.TraverseFilter[Seq]","kind":"implicit val"}}
{"package_name":"cats.instances","file_name":"cats.instances.all","short_description":"","kind":"object","case_class_link":null,"class_link":null,"object_link":"cats/instances/package$$all$.html","trait_link":null,"function_block":{"label":"catsKernelStdHashForSortedMap","tail":"(hashK: kernel.Hash[K], orderK: kernel.Order[K], hashV: kernel.Hash[V]): kernel.Hash[SortedMap[K, V]]","member":"cats.kernel.instances.SortedMapInstances.catsKernelStdHashForSortedMap","link":"cats/instances/package$$all$.html#catsKernelStdHashForSortedMap[K,V](hashK:cats.kernel.Hash[K],orderK:cats.kernel.Order[K],hashV:cats.kernel.Hash[V]):cats.kernel.Hash[scala.collection.immutable.SortedMap[K,V]]","kind":"def"}}
{"package_name":"cats.instances","file_name":"cats.instances.all","short_description":"","kind":"object","case_class_link":null,"class_link":null,"object_link":"cats/instances/package$$all$.html","trait_link":null,"function_block":{"label":"catsStdShowForFiniteDurationUnambiguous","tail":": Show[FiniteDuration]","member":"cats.instances.CoreFiniteDurationInstances.catsStdShowForFiniteDurationUnambiguous","link":"cats/instances/package$$all$.html#catsStdShowForFiniteDurationUnambiguous:cats.Show[scala.concurrent.duration.FiniteDuration]","kind":"implicit final val"}}
{"package_name":"cats.instances","file_name":"cats.instances.all","short_description":"","kind":"object","case_class_link":null,"class_link":null,"object_link":"cats/instances/package$$all$.html","trait_link":null,"function_block":{"label":"synchronized","tail":"(arg0: => T0): T0","member":"scala.AnyRef.synchronized","link":"cats/instances/package$$all$.html#synchronized[T0](x$1:=>T0):T0","kind":"final def"}}
{"package_name":"cats.data","file_name":"cats.data.AndThen","short_description":"A function type of a single input that can do function composition(via andThen and compose) in constant stack space with amortizedlinear time application (in the number of constituent functions).","kind":"class","case_class_link":null,"class_link":"cats/data/AndThen.html","object_link":"cats/data/AndThen$.html","trait_link":null,"function_block":{"label":"productElement","tail":"(n: Int): Any","member":"scala.Product.productElement","link":"cats/data/AndThen.html#productElement(n:Int):Any","kind":"abstract def"}}
{"package_name":"cats.data","file_name":"cats.data.Binested","short_description":"Compose a two-slot type constructor F[_, _] with two single-slot type constructors G[_] and H[_], resulting in a two-slot type constructor with respect to the inner types.","kind":"case class","case_class_link":"cats/data/Binested.html","class_link":null,"object_link":"cats/data/Binested$.html","trait_link":null,"function_block":{"label":"value","tail":": F[G[A], H[B]]","member":"cats.data.Binested.value","link":"cats/data/Binested.html#value:F[G[A],H[B]]","kind":"val"}}
{"package_name":"cats.data","file_name":"cats.data.BinestedBifoldable","short_description":"","kind":"class","case_class_link":null,"class_link":"cats/data/BinestedBifoldable.html","object_link":null,"trait_link":null,"function_block":{"label":"H","tail":"(): Foldable[H]","member":"cats.data.BinestedBifoldable.H","link":"cats/data/BinestedBifoldable.html#H:cats.Foldable[H]","kind":"implicit abstract def"}}
{"package_name":"cats.data","file_name":"cats.data.Chain","short_description":"Trivial catenable sequence.","kind":"class","case_class_link":null,"class_link":"cats/data/Chain.html","object_link":"cats/data/Chain$.html","trait_link":null,"function_block":{"label":":==","tail":"","member":"cats.data.Chain.:==","link":"cats/data/Chain$.html#:==","kind":"object"}}
{"package_name":"cats.data","file_name":"cats.data.EitherK","short_description":"F on the left and G on the right of scala.util.Either.","kind":"case class","case_class_link":"cats/data/EitherK.html","class_link":null,"object_link":"cats/data/EitherK$.html","trait_link":null,"function_block":{"label":"EitherKRight","tail":"","member":"cats.data.EitherK.EitherKRight","link":"cats/data/EitherK$.html#EitherKRight[F[_]]extendsAnyRef","kind":"final class"}}
{"package_name":"cats.data","file_name":"cats.data.NonEmptySeq","short_description":"A data type which represents a Seq guaranteed to contain at least one element.","kind":"class","case_class_link":null,"class_link":"cats/data/NonEmptySeq.html","object_link":"cats/data/NonEmptySeq$.html","trait_link":null,"function_block":{"label":"ZipNonEmptySeq","tail":"","member":"cats.data.NonEmptySeq.ZipNonEmptySeq","link":"cats/data/NonEmptySeq$.html#ZipNonEmptySeq[A]extendsSerializable","kind":"class"}}
{"package_name":"cats.data","file_name":"cats.data.RepresentableStore","short_description":"A generalisation of the Store comonad, for any Representable functor.","kind":"case class","case_class_link":"cats/data/RepresentableStore.html","class_link":null,"object_link":"cats/data/RepresentableStore$.html","trait_link":null,"function_block":{"label":"coflatten","tail":": RepresentableStore[F, S, RepresentableStore[F, S, A]]","member":"cats.data.RepresentableStore.coflatten","link":"cats/data/RepresentableStore.html#coflatten:cats.data.RepresentableStore[F,S,cats.data.RepresentableStore[F,S,A]]","kind":"lazy val"}}
{"package_name":"cats.syntax","file_name":"cats.syntax.all","short_description":"","kind":"object","case_class_link":null,"class_link":null,"object_link":"cats/syntax/package$$all$.html","trait_link":null,"function_block":{"label":"catsSyntaxSeqs","tail":"(va: Seq[A]): SeqOps[A]","member":"cats.syntax.SeqSyntax.catsSyntaxSeqs","link":"cats/syntax/package$$all$.html#catsSyntaxSeqs[A](va:Seq[A]):cats.syntax.SeqOps[A]","kind":"implicit final def"}}
{"package_name":"cats.syntax","file_name":"cats.syntax.ContravariantMonoidalOps","short_description":"","kind":"class","case_class_link":null,"class_link":"cats/syntax/ContravariantMonoidalOps.html","object_link":null,"trait_link":null,"function_block":{"label":"typeClassInstance","tail":": TypeClassType","member":"cats.ContravariantMonoidal.Ops.typeClassInstance","link":"cats/syntax/ContravariantMonoidalOps.html#typeClassInstance:Ops.this.TypeClassType","kind":"abstract val"}}
{"package_name":"cats","file_name":"cats.Align","short_description":"Align supports zipping together structures with different shapes,holding the results from either or both structures in an Ior.","kind":"trait","case_class_link":null,"class_link":null,"object_link":"cats/Align$.html","trait_link":"cats/Align.html","function_block":{"label":"ToAlignOps","tail":"","member":"cats.Align.ToAlignOps","link":"cats/Align$.html#ToAlignOpsextendsSerializable","kind":"trait"}}
{"package_name":"cats","file_name":"cats.Eval","short_description":"Eval is a monad which controls evaluation.","kind":"class","case_class_link":null,"class_link":"cats/Eval.html","object_link":"cats/Eval$.html","trait_link":null,"function_block":{"label":"FlatMap","tail":"","member":"cats.Eval.FlatMap","link":"cats/Eval$.html#FlatMap[A]extendsEval[A]","kind":"sealed abstract class"}}
{"package_name":"cats","file_name":"cats.NonEmptyParallel","short_description":"Some types that form a FlatMap, are also capable of forming an Apply that supports parallel composition.","kind":"trait","case_class_link":null,"class_link":null,"object_link":"cats/NonEmptyParallel$.html","trait_link":"cats/NonEmptyParallel.html","function_block":{"label":"Aux","tail":"","member":"cats.NonEmptyParallel.Aux","link":"cats/NonEmptyParallel$.html#Aux[M[_],F0[_]]=cats.NonEmptyParallel[M]{typeF[x]=F0[x]}","kind":"type"}}
{"package_name":"cats.arrow","file_name":"cats.arrow.FunctionK","short_description":"FunctionK[F[_], G[_]] is a functor transformation from F to Gin the same manner that function A => B is a morphism from valuesof type A to B.","kind":"trait","case_class_link":null,"class_link":null,"object_link":"cats/arrow/FunctionK$.html","trait_link":"cats/arrow/FunctionK.html","function_block":{"label":"lift","tail":"(f: (F[\u03b1]) => G[\u03b1] forSome {type \u03b1}): FunctionK[F, G]","member":"cats.arrow.FunctionKMacroMethods.lift","link":"cats/arrow/FunctionK$.html#lift[F[_],G[_]](f:F[\u03b1]=>G[\u03b1]forSome{type\u03b1}):cats.arrow.FunctionK[F,G]","kind":"macro def"}}
{}